<?php

class CRM_Oddc_Stats {
  /** @var Redis|NULL */
  public $redis;

  public function __construct($startDate = NULL, $endDate = NULL) {

    return;
    $this->setStartDate($startDate)->setEndDate($endDate);

    // See if we have Redis available.
    if (class_exists('Redis')) {
      $r = new Redis();
      if ($r->connect('/run/redis/redis.sock')) {
        if ($r->ping()) {
          $this->redis = $r;
        }
      }
    }
  }

  /**
   * Get the stats for the period.
   *
   * @param array $stats An array of stat names. These correlate like 'Foo' stat is generated by method calcStatFoo()
   * @param bool $reset  By default it will use cached versions.
   */
  public function getStats($statsToCalc = NULL, $reset = FALSE) {
    $stats = [];
    if ($statsToCalc === NULL) {
      $statsToCalc = [];
    }
    foreach ($statsToCalc as $stat) {
      $m = "calcStat$stat";
      if (method_exists($this, $m)) {
        $cacheKey = 'oddStats_' . md5(json_encode([$this->startDate, $this->endDate, $stat]));

        if ($this->redis) {
          if (!$reset && $this->redis->exists($cacheKey)) {
            $cached = $this->redis->get($cacheKey);
            $cached = json_decode($cached, TRUE);
            if (is_array($cached)) {
              $stats += $cached;
            }
            else {
              $stats[$stat] = $cached;
            }
            continue;
          }
        }

        // No redis, or not found. Do the work now.
        $value = $this->$m();

        if (is_array($value)) {
          $stats += $value;
        }
        else {
          $stats[$stat] = $value;
        }
        if ($this->redis) {
          // Store it until midnight.
          $this->redis->set($cacheKey, json_encode($value), 60*60*(24 - (int) date('H')));
        }
      }
      else {
        throw new BadMethodCallException("$stat is invalid stat.");
      }
    }

    foreach ($stats as &$_) {
      if ($_ !== NULL) {
        $_ = (float) $_;
      }
    }
    unset($_);

    // Meta stats
    if (!empty($stats['churnPercent']) && !empty($stats['regularDonorIncome'])) {
      // Just an alias
    }

    ksort($stats);
    return $stats;
  }
  /**
   * Given a date, generate a list of dates for the first and last second of the
   * month up to this month.
   *
   * @param string Something strtotime can understand.
   * @return array
   */
  public function getMonthDates($from) {
    // Get first of month.
    $given = new DateTimeImmutable($from);
    $startOfMonth = $given->modify('first day of');
    $endOfMonth = $startOfMonth->modify('+1 month - 1 second');
    $now = new DateTimeImmutable('today');

    $months = [];
    while ($startOfMonth < $now) {
      $months[] = [$startOfMonth->format('c'), $endOfMonth->format('c')];
      $startOfMonth = $startOfMonth->modify('+1 month');
      $endOfMonth = $startOfMonth->modify('+1 month -1 second');
    }
    return $months;
  }
}

class Statx {
  /**
   * @var Array
   */
  public $params = [];

  protected $statProviderIndex = [];
  public $providers = [
    'StatXGeneric' => [
      'params' => ['startDate', 'endDate'],
      'methods' => [
        'calcStatOneOffDonors' => [
          'depends' => [],
          'provides' => [
            'oneOffDonorCount', 'oneOffDonorIncome', 'oneOffDonorAvgAmount',
            'oneOffDonorCountSourceOther', 'oneOffDonorIncomeSourceOther', 'oneOffDonorAvgAmountSourceOther',
            'oneOffDonorCountSourceSocial', 'oneOffDonorIncomeSourceSocial', 'oneOffDonorAvgAmountSourceSocial',
            'oneOffDonorCountSourceWebsite', 'oneOffDonorIncomeSourceWebsite', 'oneOffDonorAvgAmountSourceWebsite',
            'oneOffDonorCountSourceEmail', 'oneOffDonorIncomeSourceEmail', 'oneOffDonorAvgAmountSourceEmail',
          ],
        ],
        'calcStatRegularDonors' => [
          'depends' => [],
          'provides' => [
            'regularDonorCount', 'regularDonorIncome', 'regularDonorAvgAmount',
            'regularDonorCountSourceOther', 'regularDonorIncomeSourceOther', 'regularDonorAvgAmountSourceOther',
            'regularDonorCountSourceSocial', 'regularDonorIncomeSourceSocial', 'regularDonorAvgAmountSourceSocial',
            'regularDonorCountSourceWebsite', 'regularDonorIncomeSourceWebsite', 'regularDonorAvgAmountSourceWebsite',
            'regularDonorCountSourceEmail', 'regularDonorIncomeSourceEmail', 'regularDonorAvgAmountSourceEmail',
          ],
        ],
        'calcStatRegularRetentionAnnual' => [
          'depends' => [],
          'provides' => [
            'annualRetainedRegularDonorsCount',
            'annualRetainedRegularDonorsPercent',
            'annualPreviousRegularDonorsCount',
          ],
        ],
        'calcStatRegularRetentionMonthly' => [
          'depends' => [],
          'provides' => [
            'monthlyRetainedRegularDonorsCount',
            'monthlyRetainedRegularDonorsPercent',
            'monthlyPreviousRegularDonorsCount',
            'churnPercent',
          ],
        ],
        'calcStatRegularRecruitmentAnnual' => [
          'depends' => [],
          'provides' => [
            'annualNewDonors',
            'annualOldDonors',
            'annualRecruitmentPercent',
          ],
        ],
        'calcStatRegularRecruitmentMonthly' => [
          'depends' => [],
          'provides' => [
            'monthlyNewDonors',
            'monthlyOldDonors',
            'monthlyRecruitmentPercent',
          ],
        ],
        'calcStatOneOffSpecial' => [
          'depends' => [],
          'provides' => [
            'oneOffDonorsRepeat',
            'oneOffDonors1st',
            'oneOffDonors2nd',
            'oneOffDonors3rd',
            'oneOffDonors4th',
            'oneOffDonors5OrMore',
            'oneOffsFromRegularDonor',
          ],
        ],
        'calcStatMarketing' => [
          'depends' => [
            'regularDonorIncome',
            'regularDonorCount',
            'churnPercent',
          ],
          'provides' => [ 'MRR', 'ARR', 'ARPU', 'LTV' ]
        ]
      ],
    ],
  ];
  /**
   * @var array of provider objects.
   */
  protected $singletons = [];

  /**
   * @var Array cache of calculated stats.
   */
  public $outputs = [];

  /**
   */
  public function __construct($params = []) {
    $this->params = $params;

    // @todo hook to let others add defintions.

    // Index the stats.
    foreach ($this->providers as $providerClass => $providerDetails) {
      foreach ($providerDetails['methods'] as $methodName => $methodDetails) {
        foreach ($methodDetails['provides'] as $stat) {
          $this->statProviderIndex[$stat] = [$providerClass, $methodName];
        }
      }
    }
  }

  /**
   * Calculate a set of required stats.
   */
  public function get($stats) {
    return $this->runStats($stats)->outputs;
  }
  /**
   * Recursively get stats
   *
   * @var array $stats stat names
   * @var array $list (used internally)
   *
   * @return Statx
   */
  public function runStats($stats) {

    foreach ($stats as $statName) {

      $provider = $this->statProviderIndex[$statName] ?? NULL;
      if (!$provider) {
        throw new \InvalidArgumentException("'$statName' has no registered provider.");
      }

      // Do we have one of these objects?
      $providerClass = $provider[0];
      $providerMethod = $provider[1];
      $providerDetails = $this->providers[$providerClass];
      if (!isset($this->singletons[$providerClass])) {
        $args = [$this];
        foreach ($providerDetails['params'] ?? [] as $input) {
          $args[] = $this->getParam($input);
        }
        $this->singletons[$providerClass] = new $providerClass(...$args);
      }

      $methodDetails = $providerDetails['methods'][$providerMethod];
      // Depth-first, see if there are dependencies.
      if (!empty($methodDetails['depends'])) {
        $this->runStats($methodDetails['depends']);
      }
      // All dependencies met.

      // Has the stat already been calculated (e.g. one method that provides several)
      if (!isset($this->outputs[$statName])) {
        // Calc stats.
        $this->singletons[$providerClass]->$providerMethod();
      }
    }

    return $this;
  }

  public function getParam($name, $default=NULL) {
    return $this->params[$name] ?? $default;
  }
  public function getOutput($name) {
    return $this->outputs[$name];
  }
  public function setOutput($name, $value) {
    $this->outputs[$name] = $value;
  }
  public function setOutputs($keyValuePairs) {
    $this->outputs = array_merge($this->outputs, $keyValuePairs);
  }
}

class StatXGeneric {
  public $startDate;
  public $endDate;
  public $startDateTime;
  public $endDateTime;


  public $statx;

  public function __construct($statx, $start, $end) {
    $this->statx = $statx;
    $this->setStartDate($start)->setEndDate($end);
  }
  public function setStartDate($date) {
    if (!$date) {
      $this->startDate = NULL;
      $this->startDateTime = NULL;
    }
    else {
      $this->startDateTime = new DateTimeImmutable($date);
      $this->startDate = $this->startDateTime->format('YmdHis');
    }
    return $this;
  }

  public function setEndDate($date) {
    if (!$date) {
      $this->endDate = NULL;
      $this->endDateTime = NULL;
    }
    else {
      $this->endDateTime = new DateTimeImmutable($date);
      $this->endDate = $this->endDateTime->format('YmdHis');
    }
    return $this;
  }


  /**
   * How many donors making regular donations did we have in the period?
   *
   * This is MMR, assuming the period specified is a month.
   */
  public function calcStatRegularDonors() {
    $this->statx->setOutputs($this->basic(TRUE));
  }

  /**
   * How many donors making non-regulr donations did we have in the period?
   */
  public function calcStatOneOffDonors($obj) {
    $this->statx->setOutputs($this->basic(FALSE));
  }

  /**
   * How many donors making non-regulr donations did we have in the period?
   * @param bool $is_recurring
   *
   * @return array
   */
  protected function basic($isRecurring) {

    $isRecurringClause = $isRecurring ? 'IS NOT NULL' : 'IS NULL';

    $sql = "
WITH simplifiedSource AS (
  SELECT
    CASE
    WHEN source LIKE 'mailing%' THEN 'email'
    WHEN source LIKE '|website|%' THEN 'website'
    WHEN source LIKE 'website-%' THEN 'website'
    WHEN source LIKE '|social|%' THEN 'social'
    ELSE 'other'
    END source,
    contact_id,
    total_amount
  FROM civicrm_contribution cc
  WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
  AND is_test=0
  AND contribution_status_id = 1
  AND contribution_recur_id $isRecurringClause
)

SELECT
  source,
  COUNT(DISTINCT contact_id) DonorCount,
  SUM(total_amount) DonorIncome,
  ROUND(SUM(total_amount)/COUNT(contact_id), 2) DonorAvgAmount
FROM simplifiedSource
GROUP BY source WITH ROLLUP
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);

    $prefix = $isRecurring ? 'regular' : 'oneOff';

    while ($dao->fetch()) {
      $suffix = '';
      if ($dao->source) {
        $suffix = 'Source' . ucfirst($dao->source);
      }
      foreach (['DonorCount', 'DonorIncome', 'DonorAvgAmount'] as $s) {
        $stats[ $prefix . $s . $suffix ] = $dao->$s;
      }
    }
    return $stats;
  }


  /**
   * Annual retention rate
   *
   * This is the year up-to the start date.
   *
   * Number of people who gave a regular donation in this month and also gave one in "this month a year ago"
   *                                รท
   * Number of people who gave a regular donation in "this month a year ago"
   *
   * 0 - 100%
   *
   */
  public function calcStatRegularRetentionAnnual() {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRetentionAnnual");
    }
    $referenceMonthStartDateTime = $this->startDateTime->modify('-1 year');
    $stats = $this->retentionRates($referenceMonthStartDateTime);

    return [
        'annualRetainedRegularDonorsCount'   => $stats['retainedCount'],
        'annualRetainedRegularDonorsPercent' => $stats['retainedPercentage'],
        'annualPreviousRegularDonorsCount'   => $stats['referenceDonorCount'],
    ];
  }

  /**
   * Monthly retention rate
   *
   * This compares the given month with the one before it.
   *
   * Churn = number of people lost in this month รท number of donors in the month before
   *
   * The Simple Way from
   * https://www.profitwell.com/customer-churn/calculate-churn-rate
   */
  public function calcStatRegularRetentionMonthly() {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRetentionMonthly");
    }
    $referenceMonthStartDateTime = $this->startDateTime->modify('-1 month');
    $stats = $this->retentionRates($referenceMonthStartDateTime);

    $stats = [
        'monthlyRetainedRegularDonorsCount'   => $stats['retainedCount'],
        'monthlyRetainedRegularDonorsPercent' => $stats['retainedPercentage'],
        'monthlyPreviousRegularDonorsCount'   => $stats['referenceDonorCount'],
        'churnPercent'                        => round(
          ($stats['referenceDonorCount'] - $stats['retainedCount']) / $stats['referenceDonorCount'] * 100
          , 1)
    ];
    $this->statx->setOutputs($stats);
  }

  /**
   * Retention
   *
   * This compares the given month with the reference month.
   *
   * @param DateTimeImmutable
   */
  protected function retentionRates(DateTimeImmutable $referenceMonthStartDateTime) {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRetentionAnnual");
    }
    if (!$this->endDate) {
      throw BadMethodCallException("Need endDate for calcStatRegularRetentionAnnual");
    }

    $refMonthStart = $referenceMonthStartDateTime->format('YmdHis');
    $refMonthEndDateTime = $referenceMonthStartDateTime->modify('+1 month -1 second');
    $refMonthEnd = $refMonthEndDateTime->format('YmdHis');

    // Number of people who gave regular donation in this month and the previous month
    // divided by the number of people who also gave in the previous month. 0 - 100%
    $sql = "
WITH lastMonthsDonors AS (
SELECT contact_id
FROM civicrm_contribution
WHERE receive_date >= $refMonthStart AND receive_date <= $refMonthEnd
AND contribution_recur_id IS NOT NULL
AND contribution_status_id = 1
AND is_test = 0
GROUP BY contact_id
),

thisMonthsDonors AS (
SELECT contact_id
FROM civicrm_contribution
WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
AND contribution_recur_id IS NOT NULL
AND contribution_status_id = 1
AND is_test = 0
GROUP BY contact_id
)

SELECT
  SUM(thisMonthsDonors.contact_id IS NOT NULL) retainedCount,
  COUNT(lastMonthsDonors.contact_id) referenceDonorCount,
  ROUND(SUM(thisMonthsDonors.contact_id IS NOT NULL) * 100 / COUNT(lastMonthsDonors.contact_id), 1) retainedPercentage
FROM lastMonthsDonors
LEFT JOIN thisMonthsDonors ON lastMonthsDonors.contact_id = thisMonthsDonors.contact_id
      ;
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    else {
      return [
        'retainedCount' => NULL,
        'referenceDonorCount' => NULL,
        'retainedPercentage' => NULL,
        'referencePeriod' => [$referenceMonthStartDateTime, $refMonthEndDateTime]
      ];
    }
  }

  /**
   * Annual recruitment rate
   *
   * xxx I'm unsure about this one.
   *
   * a) How many donors have been recruited since last year? And what's that as a %age of the regular donors at the end of last year?
   *
   * b) How many of our current regular donors were recruited since last year? And what's that as a %age of the regular donors at the end of last year?
   *
   * Consider this:
   *
   * - It's now Aug 2020
   * - Neither Wilma nor Betty were donors in Aug 2019, both signed up in Jan 2020
   * - Wilma has since stopped giving, and as such is no longer a regular donor.
   *
   * Under method (a), we'd say we have 2 recruits. Under (b) we'd say we have 1.
   */
  public function calcStatRegularRecruitmentAnnual() {
    return NULL;

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRecruitmentAnnual");
    }
    if (!$this->endDate) {
      throw BadMethodCallException("Need endDate for calcStatRegularRecruitmentAnnual");
    }

    // Number of people who gave regular donation this year/year but had not
    // given a regular donation in the previous year/year
    //
    // divided by the number of people who gave regular donation in previous
    // year/year.
    //
    // 0 - 100+%
    $sql = "
      WITH lastYearsDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $this->startDate - INTERVAL 2 YEAR AND receive_date < $this->startDate - INTERVAL 1 YEAR
      AND contribution_recur_id IS NOT NULL
      AND contribution_status_id = 1
      AND is_test = 0
      GROUP BY contact_id
      ),

      thisYearsNewDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $this->startDate - INTERVAL 1 YEAR AND receive_date < $this->startDate
      AND contribution_recur_id IS NOT NULL
      AND contribution_status_id = 1
      AND is_test = 0
      AND NOT EXISTS (SELECT contact_id FROM lastYearsDonors lm WHERE lm.contact_id = civicrm_contribution.contact_id)
      GROUP BY contact_id
      ),

      counts AS (
        SELECT (SELECT COUNT(*) FROM thisYearsNewDonors) newDonors,
               (SELECT COUNT(*) FROM lastYearsDonors) oldDonors
      )

      SELECT newDonors annualNewDonors,
        oldDonors annualOldDonors,
        newDonors / oldDonors * 100 annualRecruitmentPercent
      FROM counts
      ;
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      $stats = $dao->toArray();
    }
    else {
      $stats = [
        'annualNewDonors' => NULL,
        'annualOldDonors' => NULL,
        'annualRecruitmentPercent' => NULL,
      ];
    }
    $this->statx->setOutputs($stats);
  }

  /**
   * Monthly recruitment rate
   */
  public function calcStatRegularRecruitmentMonthly() {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRecruitmentMonthly");
    }
    if (!$this->endDate) {
      throw BadMethodCallException("Need endDate for calcStatRegularRecruitmentMonthly");
    }

    $lastMonthStartDateTime = $this->startDateTime->modify('-1 month');
    $lastMonthStart = $lastMonthStartDateTime->format('YmdHis');
    $lastMonthEndDateTime = $lastMonthStartDateTime->modify('+ 1 month - 1 second');
    $lastMonthEndDate = $lastMonthEndDateTime->format('YmdHis');

    // Number of people who gave regular donation this year/month but had not
    // given a regular donation in the previous year/month
    //
    // divided by the number of people who gave regular donation in previous
    // year/month.
    //
    // 0 - 100+%
    $sql = "
      WITH lastMonthsDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $lastMonthStart AND receive_date <= $lastMonthEndDate
      AND contribution_recur_id IS NOT NULL
      AND is_test = 0
      AND contribution_status_id = 1
      GROUP BY contact_id
      ),

      thisMonthsNewDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
      AND contribution_recur_id IS NOT NULL
      AND is_test = 0
      AND contribution_status_id = 1
      AND NOT EXISTS (SELECT contact_id FROM lastMonthsDonors lm WHERE lm.contact_id = civicrm_contribution.contact_id)
      GROUP BY contact_id
      ),

      counts AS (
        SELECT (SELECT COUNT(*) FROM thisMonthsNewDonors) newDonors,
               (SELECT COUNT(*) FROM lastMonthsDonors) oldDonors
      )

      SELECT newDonors monthlyNewDonors,
        oldDonors monthlyOldDonors,
        newDonors / oldDonors * 100 monthlyRecruitmentPercent
      FROM counts
      ;
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      $stats = $dao->toArray();
    }
    else {
      $stats = [
        'monthlyNewDonors' => NULL,
        'monthlyOldDonors' => NULL,
        'monthlyRecruitmentPercent' => NULL,
      ];
    }

    $this->statx->setOutputs($stats);
  }

  /**
   *
   */
  public function calcStatOneOffSpecial() {

    $sql = "
WITH thisMonthsDonors AS (
  SELECT
    contact_id
  FROM civicrm_contribution cc
  WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
  AND is_test=0
  AND contribution_status_id = 1
  AND contribution_recur_id IS NULL
  GROUP BY contact_id
),
previousGiving AS (
  SELECT contact_id,
    COUNT(id) totalContribs,
    SUM(contribution_recur_id IS NULL) totalOneOffs
  FROM civicrm_contribution
  WHERE receive_date < $this->startDate
  AND is_test=0
  AND contribution_status_id = 1
  GROUP BY contact_id
)

SELECT
  SUM(previousGiving.totalContribs IS NULL) AS oneOffDonors1st,
  SUM(previousGiving.totalOneOffs > 0) AS oneOffDonorsRepeat,
  SUM(previousGiving.totalOneOffs = 1) AS oneOffDonors2nd,
  SUM(previousGiving.totalOneOffs = 2) AS oneOffDonors3rd,
  SUM(previousGiving.totalOneOffs = 3) AS oneOffDonors4th,
  SUM(previousGiving.totalOneOffs > 3) AS oneOffDonors5OrMore,
  SUM(previousGiving.totalContribs > 0 AND previousGiving.totalOneOffs = 0) AS oneOffsFromRegularDonor
FROM thisMonthsDonors
LEFT JOIN previousGiving ON thisMonthsDonors.contact_id = previousGiving.contact_id
";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      $stats = $dao->toArray();
    }
    $stats = [
      'oneOffDonorsRepeat' => 0,
      'oneOffDonors1st' => 0,
      'oneOffDonors2nd' => 0,
      'oneOffDonors3rd' => 0,
      'oneOffDonors4th' => 0,
      'oneOffDonors5OrMore' => 0,
      'oneOffsFromRegularDonor' => 0,
    ];
    $this->statx->setOutputs($stats);
  }

  /**
   * Year to date from one offs.
   */
  public function calcStatOneOffYearToDate() {

    $startOfYear = date('Y') . '0101000000';
    $sql = "
      SELECT SUM(total_amount) oneOffYearToDate
      FROM civicrm_contribution cc
      WHERE receive_date >= $startOfYear
      AND is_test=0
      AND contribution_status_id = 1
      AND contribution_recur_id IS NULL
    ";

    $this->statx->setOutput('OneOffYearToDate', CRM_Core_DAO::singleValueQuery($sql));
  }

  /**
   * Target
   *
   */
  public function calcStatTarget() {

    $sql = "
      SELECT ROUND(SUM(total_amount)/ 500000 * 100) targetPercent,
             ROUND(SUM((contribution_recur_id IS NOT NULL) * total_amount)/ 500000 * 100) targetPercentRegular
      FROM civicrm_contribution cc
      WHERE receive_date >= $this->endDate - INTERVAL 1 YEAR
          AND receive_date <= $this->endDate
      AND is_test=0
      AND contribution_status_id = 1
    ";
    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    return [
      'targetPercent' => 0,
      'targetPercentRegular' => 0,
    ];

  }

  public function calcStatMarketing() {

    $stats = [];
    // Monthly Recurring Revenue
    $stats['MRR'] = $this->statx->getOutput('regularDonorIncome');
    // Annual Recurring Revenue
    $stats['ARR'] = 12 * $stats['MRR'];

    // Average Revenue Per User (donor)
    $arpu =  $stats['ARR'] / $this->statx->getOutput('regularDonorCount');
    // Lifetime Value
    $stats['LTV'] = round($arpu / ($this->statx->getOutput('churnPercent') / 100));
    $stats['ARPU'] = round($arpu);

    $this->statx->setOutputs($stats);
  }
}
