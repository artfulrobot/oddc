<?php

class CRM_Oddc_Stats {
  public $startDate;
  public $endDate;
  public $startDateTime;
  public $endDateTime;
  /** @var Redis|NULL */
  public $redis;

  public function __construct($startDate = NULL, $endDate = NULL) {

    $this->setStartDate($startDate)->setEndDate($endDate);

    // See if we have Redis available.
    if (class_exists('Redis')) {
      $r = new Redis();
      if ($r->connect('/run/redis/redis.sock')) {
        if ($r->ping() !== '+PONG') {
          $this->redis = $r;
        }
      }
    }
  }

  public function setStartDate($date) {
    if (!$date) {
      $this->startDate = NULL;
      $this->startDateTime = NULL;
    }
    else {
      $this->startDateTime = new DateTimeImmutable($date);
      $this->startDate = $this->startDateTime->format('YmdHis');
    }
    return $this;
  }

  public function setEndDate($date) {
    if (!$date) {
      $this->endDate = NULL;
      $this->endDateTime = NULL;
    }
    else {
      $this->endDateTime = new DateTimeImmutable($date);
      $this->endDate = $this->endDateTime->format('YmdHis');
    }
    return $this;
  }

  /**
   * Get the stats for the period.
   *
   * @param array $stats An array of stat names. These correlate like 'Foo' stat is generated by method calcStatFoo()
   * @param bool $reset  By default it will use cached versions.
   */
  public function getStats($statsToCalc = NULL, $reset = FALSE) {
    $stats = [];
    if ($statsToCalc === NULL) {
      $statsToCalc = [];
    }
    foreach ($statsToCalc as $stat) {
      $m = "calcStat$stat";
      if (method_exists($this, $m)) {
        $cacheKey = 'oddStats_' . md5(json_encode([$this->startDate, $this->endDate, $stat]));

        if ($this->redis) {
          if (!$reset && $this->redis->exists($cacheKey)) {
            $cached = $this->redis->get($cacheKey);
            $cached = json_decode($cached, TRUE);
            if (is_array($cached)) {
              $stats += $cached;
            }
            else {
              $stats[$stat] = $cached;
            }
            continue;
          }
        }

        // No redis, or not found. Do the work now.
        $value = $this->$m();

        if (is_array($value)) {
          $stats += $value;
        }
        else {
          $stats[$stat] = $value;
        }
        if ($this->redis) {
          // Store it until midnight.
          $this->redis->set($cacheKey, json_encode($value), 60*60*(24 - (int) date('H')));
        }
      }
      else {
        throw new BadMethodCallException("$stat is invalid stat.");
      }
    }

    ksort($stats);
    foreach ($stats as &$_) {
      if ($_ !== NULL) {
        $_ = (float) $_;
      }
    }
    unset($_);
    return $stats;
  }
  /**
   * Given a date, generate a list of dates for the first and last second of the
   * month up to this month.
   *
   * @param string Something strtotime can understand.
   * @return array
   */
  public function getMonthDates($from) {
    // Get first of month.
    $given = new DateTimeImmutable($from);
    $startOfMonth = $given->modify('first day of');
    $endOfMonth = $startOfMonth->modify('+1 month - 1 second');
    $now = new DateTimeImmutable('today');

    $months = [];
    while ($startOfMonth < $now) {
      $months[] = [$startOfMonth->format('c'), $endOfMonth->format('c')];
      $startOfMonth = $startOfMonth->modify('+1 month');
      $endOfMonth = $startOfMonth->modify('+1 month -1 second');
    }
    return $months;
  }
  /**
   * How many donors making regular donations did we have in the period?
   */
  public function calcStatRegularDonors() {
    return $this->basic(TRUE);
  }

  /**
   * How many donors making non-regulr donations did we have in the period?
   */
  public function calcStatOneOffDonors() {
    return $this->basic(FALSE);
  }

  /**
   * How many donors making non-regulr donations did we have in the period?
   * @param bool $is_recurring
   */
  protected function basic($isRecurring) {

    $isRecurringClause = $isRecurring ? 'IS NOT NULL' : 'IS NULL';

    $sql = "
WITH simplifiedSource AS (
  SELECT
    CASE
    WHEN source LIKE 'mailing%' THEN 'email'
    WHEN source LIKE '|website|%' THEN 'website'
    WHEN source LIKE 'website-%' THEN 'website'
    WHEN source LIKE '|social|%' THEN 'social'
    ELSE 'other'
    END source,
    contact_id,
    total_amount
  FROM civicrm_contribution cc
  WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
  AND is_test=0
  AND contribution_status_id = 1
  AND contribution_recur_id $isRecurringClause
)

SELECT
  source,
  COUNT(DISTINCT contact_id) DonorCount,
  SUM(total_amount) DonorIncome,
  ROUND(SUM(total_amount)/COUNT(contact_id), 2) DonorAvgAmount
FROM simplifiedSource
GROUP BY source WITH ROLLUP
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);

    $prefix = $isRecurring ? 'regular' : 'oneOff';

    while ($dao->fetch()) {
      $suffix = '';
      if ($dao->source) {
        $suffix = 'Source' . ucfirst($dao->source);
      }
      foreach (['DonorCount', 'DonorIncome', 'DonorAvgAmount'] as $s) {
        $stats[ $prefix . $s . $suffix ] = $dao->$s;
      }
    }
    return $stats;
  }

  /**
   * Annual retention rate
   *
   * This is the year up-to the start date.
   *
   * Number of people who gave a regular donation in this month and also gave one in "this month a year ago"
   *                                รท
   * Number of people who gave a regular donation in "this month a year ago"
   *
   * 0 - 100%
   *
   */
  public function calcStatRegularRetentionAnnual() {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRetentionAnnual");
    }
    $referenceMonthStartDateTime = $this->startDateTime->modify('-1 year');
    $stats = $this->retentionRates($referenceMonthStartDateTime);

    return [
        'annualRetainedRegularDonorsCount'   => $stats['retainedCount'],
        'annualRetainedRegularDonorsPercent' => $stats['retainedPercentage'],
        'annualPreviousRegularDonorsCount'   => $stats['referenceDonorCount'],
    ];
  }

  /**
   * Monthly retention rate
   *
   * This compares the given month with the one before it.
   */
  public function calcStatRegularRetentionMonthly() {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRetentionMonthly");
    }
    $referenceMonthStartDateTime = $this->startDateTime->modify('-1 month');
    $stats = $this->retentionRates($referenceMonthStartDateTime);

    return [
        'monthlyRetainedRegularDonorsCount'   => $stats['retainedCount'],
        'monthlyRetainedRegularDonorsPercent' => $stats['retainedPercentage'],
        'monthlyPreviousRegularDonorsCount'   => $stats['referenceDonorCount'],
    ];
  }

  /**
   * Retention
   *
   * This compares the given month with the reference month.
   *
   * @param DateTimeImmutable
   */
  protected function retentionRates(DateTimeImmutable $referenceMonthStartDateTime) {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRetentionAnnual");
    }
    if (!$this->endDate) {
      throw BadMethodCallException("Need endDate for calcStatRegularRetentionAnnual");
    }

    $refMonthStart = $referenceMonthStartDateTime->format('YmdHis');
    $refMonthEndDateTime = $referenceMonthStartDateTime->modify('+1 month -1 second');
    $refMonthEnd = $refMonthEndDateTime->format('YmdHis');

    // Number of people who gave regular donation in this month and the previous month
    // divided by the number of people who also gave in the previous month. 0 - 100%
    $sql = "
WITH lastMonthsDonors AS (
SELECT contact_id
FROM civicrm_contribution
WHERE receive_date >= $refMonthStart AND receive_date <= $refMonthEnd
AND contribution_recur_id IS NOT NULL
AND contribution_status_id = 1
AND is_test = 0
GROUP BY contact_id
),

thisMonthsDonors AS (
SELECT contact_id
FROM civicrm_contribution
WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
AND contribution_recur_id IS NOT NULL
AND contribution_status_id = 1
AND is_test = 0
GROUP BY contact_id
)

SELECT
  SUM(thisMonthsDonors.contact_id IS NOT NULL) retainedCount,
  COUNT(lastMonthsDonors.contact_id) referenceDonorCount,
  ROUND(SUM(thisMonthsDonors.contact_id IS NOT NULL) * 100 / COUNT(lastMonthsDonors.contact_id), 1) retainedPercentage
FROM lastMonthsDonors
LEFT JOIN thisMonthsDonors ON lastMonthsDonors.contact_id = thisMonthsDonors.contact_id
      ;
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    else {
      return [
        'retainedCount' => NULL,
        'referenceDonorCount' => NULL,
        'retainedPercentage' => NULL,
        'referencePeriod' => [$referenceMonthStartDateTime, $refMonthEndDateTime]
      ];
    }
  }

  /**
   * Annual recruitment rate
   *
   * xxx I'm unsure about this one.
   *
   * a) How many donors have been recruited since last year? And what's that as a %age of the regular donors at the end of last year?
   *
   * b) How many of our current regular donors were recruited since last year? And what's that as a %age of the regular donors at the end of last year?
   *
   * Consider this:
   *
   * - It's now Aug 2020
   * - Neither Wilma nor Betty were donors in Aug 2019, both signed up in Jan 2020
   * - Wilma has since stopped giving, and as such is no longer a regular donor.
   *
   * Under method (a), we'd say we have 2 recruits. Under (b) we'd say we have 1.
   */
  public function calcStatRegularRecruitmentAnnual() {
    return NULL;

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRecruitmentAnnual");
    }
    if (!$this->endDate) {
      throw BadMethodCallException("Need endDate for calcStatRegularRecruitmentAnnual");
    }

    // Number of people who gave regular donation this year/year but had not
    // given a regular donation in the previous year/year
    //
    // divided by the number of people who gave regular donation in previous
    // year/year.
    //
    // 0 - 100+%
    $sql = "
      WITH lastYearsDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $this->startDate - INTERVAL 2 YEAR AND receive_date < $this->startDate - INTERVAL 1 YEAR
      AND contribution_recur_id IS NOT NULL
      AND contribution_status_id = 1
      AND is_test = 0
      GROUP BY contact_id
      ),

      thisYearsNewDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $this->startDate - INTERVAL 1 YEAR AND receive_date < $this->startDate
      AND contribution_recur_id IS NOT NULL
      AND contribution_status_id = 1
      AND is_test = 0
      AND NOT EXISTS (SELECT contact_id FROM lastYearsDonors lm WHERE lm.contact_id = civicrm_contribution.contact_id)
      GROUP BY contact_id
      ),

      counts AS (
        SELECT (SELECT COUNT(*) FROM thisYearsNewDonors) newDonors,
               (SELECT COUNT(*) FROM lastYearsDonors) oldDonors
      )

      SELECT newDonors annualNewDonors,
        oldDonors annualOldDonors,
        newDonors / oldDonors * 100 annualRecruitmentPercent
      FROM counts
      ;
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    else {
      return [
        'annualNewDonors' => NULL,
        'annualOldDonors' => NULL,
        'annualRecruitmentPercent' => NULL,
      ];
    }
  }

  /**
   * Monthly recruitment rate
   */
  public function calcStatRegularRecruitmentMonthly() {

    if (!$this->startDate) {
      throw BadMethodCallException("Need startDate for calcStatRegularRecruitmentMonthly");
    }
    if (!$this->endDate) {
      throw BadMethodCallException("Need endDate for calcStatRegularRecruitmentMonthly");
    }

    $lastMonthStartDateTime = $this->startDateTime->modify('-1 month');
    $lastMonthStart = $lastMonthStartDateTime->format('YmdHis');
    $lastMonthEndDateTime = $lastMonthStartDateTime->modify('+ 1 month - 1 second');
    $lastMonthEndDate = $lastMonthEndDateTime->format('YmdHis');

    // Number of people who gave regular donation this year/month but had not
    // given a regular donation in the previous year/month
    //
    // divided by the number of people who gave regular donation in previous
    // year/month.
    //
    // 0 - 100+%
    $sql = "
      WITH lastMonthsDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $lastMonthStart AND receive_date <= $lastMonthEndDate
      AND contribution_recur_id IS NOT NULL
      AND is_test = 0
      AND contribution_status_id = 1
      GROUP BY contact_id
      ),

      thisMonthsNewDonors AS (
      SELECT contact_id
      FROM civicrm_contribution
      WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
      AND contribution_recur_id IS NOT NULL
      AND is_test = 0
      AND contribution_status_id = 1
      AND NOT EXISTS (SELECT contact_id FROM lastMonthsDonors lm WHERE lm.contact_id = civicrm_contribution.contact_id)
      GROUP BY contact_id
      ),

      counts AS (
        SELECT (SELECT COUNT(*) FROM thisMonthsNewDonors) newDonors,
               (SELECT COUNT(*) FROM lastMonthsDonors) oldDonors
      )

      SELECT newDonors monthlyNewDonors,
        oldDonors monthlyOldDonors,
        newDonors / oldDonors * 100 monthlyRecruitmentPercent
      FROM counts
      ;
      ";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    else {
      return [
        'monthlyNewDonors' => NULL,
        'monthlyOldDonors' => NULL,
        'monthlyRecruitmentPercent' => NULL,
      ];
    }
  }

  /**
   *
   */
  public function calcStatOneOffSpecial() {

    $sql = "
WITH thisMonthsDonors AS (
  SELECT
    contact_id
  FROM civicrm_contribution cc
  WHERE receive_date >= $this->startDate AND receive_date <= $this->endDate
  AND is_test=0
  AND contribution_status_id = 1
  AND contribution_recur_id IS NULL
  GROUP BY contact_id
),
previousGiving AS (
  SELECT contact_id,
    COUNT(id) totalContribs,
    SUM(contribution_recur_id IS NULL) totalOneOffs
  FROM civicrm_contribution
  WHERE receive_date < $this->startDate
  AND is_test=0
  AND contribution_status_id = 1
  GROUP BY contact_id
)

SELECT
  SUM(previousGiving.totalContribs IS NULL) AS oneOffDonors1st,
  SUM(previousGiving.totalOneOffs > 0) AS oneOffDonorsRepeat,
  SUM(previousGiving.totalOneOffs = 1) AS oneOffDonors2nd,
  SUM(previousGiving.totalOneOffs = 2) AS oneOffDonors3rd,
  SUM(previousGiving.totalOneOffs = 3) AS oneOffDonors4th,
  SUM(previousGiving.totalOneOffs > 3) AS oneOffDonors5OrMore,
  SUM(previousGiving.totalContribs > 0 AND previousGiving.totalOneOffs = 0) AS oneOffsFromRegularDonor
FROM thisMonthsDonors
LEFT JOIN previousGiving ON thisMonthsDonors.contact_id = previousGiving.contact_id
";

    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    return [
      'oneOffDonorsRepeat' => 0,
      'oneOffDonors1st' => 0,
      'oneOffDonors2nd' => 0,
      'oneOffDonors3rd' => 0,
      'oneOffDonors4th' => 0,
      'oneOffDonors5OrMore' => 0,
      'oneOffsFromRegularDonor' => 0,
    ];
  }

  /**
   * Year to date from one offs.
   */
  public function calcStatOneOffYearToDate() {

    $startOfYear = date('Y') . '0101000000';
    $sql = "
      SELECT SUM(total_amount) oneOffYearToDate
      FROM civicrm_contribution cc
      WHERE receive_date >= $startOfYear
      AND is_test=0
      AND contribution_status_id = 1
      AND contribution_recur_id IS NULL
    ";

    return CRM_Core_DAO::singleValueQuery($sql);
  }

  /**
   * Target
   *
   */
  public function calcStatTarget() {

    $sql = "
      SELECT ROUND(SUM(total_amount)/ 500000 * 100) targetPercent,
             ROUND(SUM((contribution_recur_id IS NOT NULL) * total_amount)/ 500000 * 100) targetPercentRegular
      FROM civicrm_contribution cc
      WHERE receive_date >= $this->endDate - INTERVAL 1 YEAR
          AND receive_date <= $this->endDate
      AND is_test=0
      AND contribution_status_id = 1
    ";
    $dao = CRM_Core_DAO::executeQuery($sql);
    if ($dao->fetch()) {
      return $dao->toArray();
    }
    return [
      'targetPercent' => 0,
      'targetPercentRegular' => 0,
    ];

  }

}
